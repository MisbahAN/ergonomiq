<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Posture & Eye Strain Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin-bottom: 20px;
        }
        #container {
            position: relative;
            width: 960px;  /* Reduced from 1280px */
            height: 720px;
            max-width: 95vw;
            max-height: 70vh;
        }
        #videoElement {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #textOverlay {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #status {
            margin-top: 20px;
            padding: 10px 20px;
            background: #333;
            border-radius: 5px;
        }
        .alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 40px 60px;
            border-radius: 10px;
            font-size: 48px;
            font-weight: bold;
            display: none;
            z-index: 1000;
            text-align: center;
        }
        .eye-alert {
            background: rgba(255, 165, 0, 0.9);
        }
    </style>
</head>
<body>
    <h1>Posture & Eye Strain Monitor</h1>
    <div id="container">
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
        <canvas id="textOverlay"></canvas>
    </div>
    <div id="status">Initializing...</div>


    <script>
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const textOverlay = document.getElementById('textOverlay');
        const textCtx = textOverlay.getContext('2d');
        const statusDiv = document.getElementById('status');
        const postureAlertDiv = document.getElementById('postureAlert');
        const eyeAlertDiv = document.getElementById('eyeAlert');

        // Audio for alerts
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playAlertSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // Calibration variables
        let calibrationShoulderAngles = [];
        let calibrationNeckAngles = [];
        let calibrationShoulderTilts = [];
        let calibrationHeadRolls = [];
        let calibrationFrames = 0;
        let isCalibrated = false;
        let lastAlertTime = 0;
        const alertCooldown = 5000; // 5 seconds

        let shoulderBaseline, neckBaseline, tiltBaseline, headBaseline;
        let baselineNeckHeight;
        const neckForwardThreshold = 8;
        const tiltThreshold = 5;
        const headThreshold = 8;
        const neckDropRatio = 0.1;

        // Eye strain variables
        const EYE_CLOSED_THRESHOLD = 0.23;
        const STRAIN_TIME_THRESHOLD = 20 * 60 * 1000; // 20 minutes in ms
        let sessionStartTime = Date.now();
        let lastBlinkTime = Date.now();
        let blinkCount = 0;
        let currentMinute = 1;
        let blinksPerMinute = [];
        let eyeClosureEvents = 0;
        let lastEyeAlertTime = 0;

        // MediaPipe eye indices
        const LEFT_EYE_INDICES = [33, 160, 158, 133, 153, 144];
        const RIGHT_EYE_INDICES = [362, 385, 387, 263, 373, 380];

        // Helper functions
        function calculateAngle(a, b, c) {
            const ba = [a[0] - b[0], a[1] - b[1]];
            const bc = [c[0] - b[0], c[1] - b[1]];
            const dotProduct = ba[0] * bc[0] + ba[1] * bc[1];
            const magnitudeBA = Math.sqrt(ba[0] * ba[0] + ba[1] * ba[1]);
            const magnitudeBC = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]);
            const cosineAngle = dotProduct / (magnitudeBA * magnitudeBC);
            return Math.acos(Math.max(-1, Math.min(1, cosineAngle))) * (180 / Math.PI);
        }

        function euclideanDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));
        }

        function eyeAspectRatio(eyePoints) {
            const vertical1 = euclideanDistance(eyePoints[1], eyePoints[5]);
            const vertical2 = euclideanDistance(eyePoints[2], eyePoints[4]);
            const horizontal = euclideanDistance(eyePoints[0], eyePoints[3]);
            return (vertical1 + vertical2) / (2.0 * horizontal);
        }

        // Initialize MediaPipe Pose
        const pose = new Pose({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }
        });

        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // Initialize MediaPipe Face Mesh
        const faceMesh = new FaceMesh({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        let poseResults = null;
        let faceResults = null;

        pose.onResults((results) => {
            poseResults = results;
            processFrame();
        });

        faceMesh.onResults((results) => {
            faceResults = results;
        });

        function processFrame() {
            if (!canvasElement || !videoElement) return;

            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            textOverlay.width = videoElement.videoWidth;
            textOverlay.height = videoElement.videoHeight;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

            textCtx.clearRect(0, 0, textOverlay.width, textOverlay.height);

            const width = canvasElement.width;
            const height = canvasElement.height;

            // Process eye strain
            let strainWarnings = [];
            let avgEar = null;

            if (faceResults && faceResults.multiFaceLandmarks && faceResults.multiFaceLandmarks.length > 0) {
                const faceLandmarks = faceResults.multiFaceLandmarks[0];

                const leftEye = LEFT_EYE_INDICES.map(idx => [
                    faceLandmarks[idx].x * width,
                    faceLandmarks[idx].y * height
                ]);

                const rightEye = RIGHT_EYE_INDICES.map(idx => [
                    faceLandmarks[idx].x * width,
                    faceLandmarks[idx].y * height
                ]);

                const leftEar = eyeAspectRatio(leftEye);
                const rightEar = eyeAspectRatio(rightEye);
                avgEar = (leftEar + rightEar) / 2.0;

                // Blink detection
                const currentTime = Date.now();
                if (avgEar < EYE_CLOSED_THRESHOLD) {
                    if (currentTime - lastBlinkTime > 300) {
                        blinkCount++;
                        lastBlinkTime = currentTime;
                    }

                    if (avgEar < EYE_CLOSED_THRESHOLD * 0.8) {
                        eyeClosureEvents++;
                    }
                }

                // Draw eye landmarks
                canvasCtx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                [...leftEye, ...rightEye].forEach(point => {
                    canvasCtx.beginPath();
                    canvasCtx.arc(point[0], point[1], 2, 0, 2 * Math.PI);
                    canvasCtx.fill();
                });
            }

            // Calculate session time and blink rate
            const sessionTime = Date.now() - sessionStartTime;
            const minuteElapsed = Math.floor(sessionTime / 60000);

            if (minuteElapsed >= currentMinute) {
                blinksPerMinute.push(blinkCount);
                currentMinute = minuteElapsed + 1;
                blinkCount = 0;
            }

            // Check strain indicators
            const recentMinutes = Math.min(3, blinksPerMinute.length);
            if (recentMinutes > 0) {
                const recentAverage = blinksPerMinute.slice(-recentMinutes).reduce((a, b) => a + b, 0) / recentMinutes;
                if (recentAverage < 10) {
                    strainWarnings.push("LOW BLINK RATE");
                }
            }

            if (sessionTime > STRAIN_TIME_THRESHOLD) {
                strainWarnings.push("TAKE A BREAK");
            }

            if (eyeClosureEvents > 50) {
                strainWarnings.push("EYES STRAINED");
            }

            // Process posture
            if (poseResults && poseResults.poseLandmarks) {
                const landmarks = poseResults.poseLandmarks;

                const leftShoulder = [landmarks[11].x * width, landmarks[11].y * height];
                const rightShoulder = [landmarks[12].x * width, landmarks[12].y * height];
                const leftEar = [landmarks[7].x * width, landmarks[7].y * height];
                const rightEar = [landmarks[8].x * width, landmarks[8].y * height];
                const leftEye = [landmarks[2].x * width, landmarks[2].y * height];
                const rightEye = [landmarks[5].x * width, landmarks[5].y * height];

                // Calculate angles
                const shoulderAngle = calculateAngle(leftShoulder, rightShoulder, [rightShoulder[0], 0]);
                const neckAngleLeft = calculateAngle(leftEar, leftShoulder, [leftShoulder[0], 0]);
                const neckAngleRight = calculateAngle(rightEar, rightShoulder, [rightShoulder[0], 0]);
                const neckAngle = (neckAngleLeft + neckAngleRight) / 2;

                const shoulderTilt = Math.atan((rightShoulder[1] - leftShoulder[1]) / (rightShoulder[0] - leftShoulder[0] + 0.000001)) * (180 / Math.PI);
                const headRoll = Math.atan((rightEye[1] - leftEye[1]) / (rightEye[0] - leftEye[0] + 0.000001)) * (180 / Math.PI);

                // Calibration
                if (!isCalibrated && calibrationFrames < 30) {
                    calibrationShoulderAngles.push(shoulderAngle);
                    calibrationNeckAngles.push(neckAngle);
                    calibrationShoulderTilts.push(shoulderTilt);
                    calibrationHeadRolls.push(headRoll);
                    calibrationFrames++;

                    const progress = (calibrationFrames / 30) * width;
                    canvasCtx.fillStyle = 'rgba(0, 255, 255, 0.7)';
                    canvasCtx.fillRect(0, height - 20, progress, 20);
                    
                    textCtx.fillStyle = 'rgba(0, 255, 255, 1)';
                    textCtx.font = 'bold 40px Arial';
                    textCtx.fillText(`Calibrating ${calibrationFrames}/30`, 20, 60);
                    
                    statusDiv.textContent = 'Calibrating... Sit upright!';
                } else if (!isCalibrated) {
                    shoulderBaseline = calibrationShoulderAngles.reduce((a, b) => a + b) / calibrationShoulderAngles.length;
                    neckBaseline = calibrationNeckAngles.reduce((a, b) => a + b) / calibrationNeckAngles.length;
                    tiltBaseline = calibrationShoulderTilts.reduce((a, b) => a + b) / calibrationShoulderTilts.length;
                    headBaseline = calibrationHeadRolls.reduce((a, b) => a + b) / calibrationHeadRolls.length;

                    const baselineEarY = (leftEar[1] + rightEar[1]) / 2;
                    const baselineShoulderY = (leftShoulder[1] + rightShoulder[1]) / 2;
                    baselineNeckHeight = Math.abs(baselineEarY - baselineShoulderY);

                    isCalibrated = true;
                    statusDiv.textContent = 'Calibration complete!';
                    console.log('Calibration complete.');
                }

                // Draw pose
                drawConnectors(canvasCtx, landmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2, radius: 3});

                // Draw center line
                canvasCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                canvasCtx.lineWidth = 2;
                canvasCtx.beginPath();
                canvasCtx.moveTo(width / 2, 0);
                canvasCtx.lineTo(width / 2, height);
                canvasCtx.stroke();

                // Draw shoulder line
                canvasCtx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                canvasCtx.lineWidth = 2;
                canvasCtx.beginPath();
                canvasCtx.moveTo(leftShoulder[0], leftShoulder[1]);
                canvasCtx.lineTo(rightShoulder[0], rightShoulder[1]);
                canvasCtx.stroke();

                // Feedback
                if (isCalibrated) {
                    const currentTime = Date.now();
                    const earY = (leftEar[1] + rightEar[1]) / 2;
                    const shoulderY = (leftShoulder[1] + rightShoulder[1]) / 2;
                    const neckHeight = Math.abs(earY - shoulderY);
                    const neckDrop = (baselineNeckHeight - neckHeight) / baselineNeckHeight;

                    const badNeckForward = neckDrop > neckDropRatio;
                    const badSide = Math.abs(shoulderTilt - tiltBaseline) > tiltThreshold;
                    const badHead = Math.abs(headRoll - headBaseline) > headThreshold;

                    let status, color;

                    if (badNeckForward || badSide || badHead) {
                        status = "POOR POSTURE";
                        color = '#FF0000';
                        
                        if (currentTime - lastAlertTime > alertCooldown) {
                            console.log('Poor posture detected! Sit upright.');
                            playAlertSound();
                            lastAlertTime = currentTime;
                        }
                    } else {
                        status = "Good Posture";
                        color = '#00FF00';
                    }

                    // Stats
                    canvasCtx.fillStyle = color;
                    canvasCtx.font = 'bold 50px Arial';
                    canvasCtx.fillText(status, 20, 120);

                    canvasCtx.fillStyle = '#FFFFFF';
                    canvasCtx.font = '35px Arial';
                    canvasCtx.fillText(`Neck drop: ${(neckDrop * 100).toFixed(1)}%`, 20, 170);
                    canvasCtx.fillText(`Head tilt: ${headRoll.toFixed(1)}°`, 20, 210);
                    canvasCtx.fillText(`Side tilt: ${shoulderTilt.toFixed(1)}°`, 20, 250);

                    statusDiv.textContent = status;
                }
            }

            // Eye strain display on text overlay
            if (isCalibrated) {
                let yOffset = 290;

                // Display warnings in console only
                if (strainWarnings.length > 0 && Date.now() - lastEyeAlertTime > alertCooldown) {
                    console.log(`Eye strain detected: ${strainWarnings.join(', ')}`);
                    lastEyeAlertTime = Date.now();
                }

                textCtx.fillStyle = 'rgba(0, 165, 255, 1)';
                textCtx.font = '28px Arial';
                strainWarnings.forEach(warning => {
                    textCtx.fillText(warning, 20, yOffset);
                    yOffset += 35;
                });

                textCtx.fillStyle = '#FFFFFF';
                if (avgEar !== null) {
                    textCtx.fillText(`EAR: ${avgEar.toFixed(2)}`, 20, yOffset);
                    yOffset += 35;
                }

                const minutes = Math.floor(sessionTime / 60000);
                const seconds = Math.floor((sessionTime % 60000) / 1000);
                textCtx.fillText(`Session: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`, 20, yOffset);
                yOffset += 35;

                const totalBlinks = blinksPerMinute.reduce((a, b) => a + b, 0) + blinkCount;
                textCtx.fillText(`Blinks: ${totalBlinks}`, 20, yOffset);
            }

            canvasCtx.restore();
        }

        // Camera setup
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({image: videoElement});
                await faceMesh.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        camera.start();

        statusDiv.textContent = 'Starting camera... Sit upright for calibration!';
    </script>
</body>
</html>